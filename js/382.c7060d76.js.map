{"version":3,"file":"js/382.c7060d76.js","mappings":"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","sources":["webpack://chatall/./node_modules/langchain/dist/chains/combine_docs_chain.js"],"sourcesContent":["import { PromptTemplate } from \"@langchain/core/prompts\";\nimport { BaseChain } from \"./base.js\";\nimport { LLMChain } from \"./llm_chain.js\";\n/**\n * Chain that combines documents by stuffing into context.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class StuffDocumentsChain extends BaseChain {\n    static lc_name() {\n        return \"StuffDocumentsChain\";\n    }\n    get inputKeys() {\n        return [this.inputKey, ...this.llmChain.inputKeys].filter((key) => key !== this.documentVariableName);\n    }\n    get outputKeys() {\n        return this.llmChain.outputKeys;\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"llmChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"input_documents\"\n        });\n        Object.defineProperty(this, \"documentVariableName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"context\"\n        });\n        this.llmChain = fields.llmChain;\n        this.documentVariableName =\n            fields.documentVariableName ?? this.documentVariableName;\n        this.inputKey = fields.inputKey ?? this.inputKey;\n    }\n    /** @ignore */\n    _prepInputs(values) {\n        if (!(this.inputKey in values)) {\n            throw new Error(`Document key ${this.inputKey} not found.`);\n        }\n        const { [this.inputKey]: docs, ...rest } = values;\n        const texts = docs.map(({ pageContent }) => pageContent);\n        const text = texts.join(\"\\n\\n\");\n        return {\n            ...rest,\n            [this.documentVariableName]: text,\n        };\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        const result = await this.llmChain.call(this._prepInputs(values), runManager?.getChild(\"combine_documents\"));\n        return result;\n    }\n    _chainType() {\n        return \"stuff_documents_chain\";\n    }\n    static async deserialize(data) {\n        if (!data.llm_chain) {\n            throw new Error(\"Missing llm_chain\");\n        }\n        return new StuffDocumentsChain({\n            llmChain: await LLMChain.deserialize(data.llm_chain),\n        });\n    }\n    serialize() {\n        return {\n            _type: this._chainType(),\n            llm_chain: this.llmChain.serialize(),\n        };\n    }\n}\n/**\n * Combine documents by mapping a chain over them, then combining results.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class MapReduceDocumentsChain extends BaseChain {\n    static lc_name() {\n        return \"MapReduceDocumentsChain\";\n    }\n    get inputKeys() {\n        return [this.inputKey, ...this.combineDocumentChain.inputKeys];\n    }\n    get outputKeys() {\n        return this.combineDocumentChain.outputKeys;\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"llmChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"input_documents\"\n        });\n        Object.defineProperty(this, \"documentVariableName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"context\"\n        });\n        Object.defineProperty(this, \"returnIntermediateSteps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"maxTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3000\n        });\n        Object.defineProperty(this, \"maxIterations\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 10\n        });\n        Object.defineProperty(this, \"ensureMapStep\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"combineDocumentChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llmChain = fields.llmChain;\n        this.combineDocumentChain = fields.combineDocumentChain;\n        this.documentVariableName =\n            fields.documentVariableName ?? this.documentVariableName;\n        this.ensureMapStep = fields.ensureMapStep ?? this.ensureMapStep;\n        this.inputKey = fields.inputKey ?? this.inputKey;\n        this.maxTokens = fields.maxTokens ?? this.maxTokens;\n        this.maxIterations = fields.maxIterations ?? this.maxIterations;\n        this.returnIntermediateSteps = fields.returnIntermediateSteps ?? false;\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        if (!(this.inputKey in values)) {\n            throw new Error(`Document key ${this.inputKey} not found.`);\n        }\n        const { [this.inputKey]: docs, ...rest } = values;\n        let currentDocs = docs;\n        let intermediateSteps = [];\n        // For each iteration, we'll use the `llmChain` to get a new result\n        for (let i = 0; i < this.maxIterations; i += 1) {\n            const inputs = currentDocs.map((d) => ({\n                [this.documentVariableName]: d.pageContent,\n                ...rest,\n            }));\n            const canSkipMapStep = i !== 0 || !this.ensureMapStep;\n            if (canSkipMapStep) {\n                // Calculate the total tokens required in the input\n                const formatted = await this.combineDocumentChain.llmChain.prompt.format(this.combineDocumentChain._prepInputs({\n                    [this.combineDocumentChain.inputKey]: currentDocs,\n                    ...rest,\n                }));\n                const length = await this.combineDocumentChain.llmChain._getNumTokens(formatted);\n                const withinTokenLimit = length < this.maxTokens;\n                // If we can skip the map step, and we're within the token limit, we don't\n                // need to run the map step, so just break out of the loop.\n                if (withinTokenLimit) {\n                    break;\n                }\n            }\n            const results = await this.llmChain.apply(inputs, \n            // If we have a runManager, then we need to create a child for each input\n            // so that we can track the progress of each input.\n            runManager\n                ? Array.from({ length: inputs.length }, (_, i) => runManager.getChild(`map_${i + 1}`))\n                : undefined);\n            const { outputKey } = this.llmChain;\n            // If the flag is set, then concat that to the intermediate steps\n            if (this.returnIntermediateSteps) {\n                intermediateSteps = intermediateSteps.concat(results.map((r) => r[outputKey]));\n            }\n            currentDocs = results.map((r) => ({\n                pageContent: r[outputKey],\n                metadata: {},\n            }));\n        }\n        // Now, with the final result of all the inputs from the `llmChain`, we can\n        // run the `combineDocumentChain` over them.\n        const newInputs = {\n            [this.combineDocumentChain.inputKey]: currentDocs,\n            ...rest,\n        };\n        const result = await this.combineDocumentChain.call(newInputs, runManager?.getChild(\"combine_documents\"));\n        // Return the intermediate steps results if the flag is set\n        if (this.returnIntermediateSteps) {\n            return { ...result, intermediateSteps };\n        }\n        return result;\n    }\n    _chainType() {\n        return \"map_reduce_documents_chain\";\n    }\n    static async deserialize(data) {\n        if (!data.llm_chain) {\n            throw new Error(\"Missing llm_chain\");\n        }\n        if (!data.combine_document_chain) {\n            throw new Error(\"Missing combine_document_chain\");\n        }\n        return new MapReduceDocumentsChain({\n            llmChain: await LLMChain.deserialize(data.llm_chain),\n            combineDocumentChain: await StuffDocumentsChain.deserialize(data.combine_document_chain),\n        });\n    }\n    serialize() {\n        return {\n            _type: this._chainType(),\n            llm_chain: this.llmChain.serialize(),\n            combine_document_chain: this.combineDocumentChain.serialize(),\n        };\n    }\n}\n/**\n * Combine documents by doing a first pass and then refining on more documents.\n * @augments BaseChain\n * @augments RefineDocumentsChainInput\n */\nexport class RefineDocumentsChain extends BaseChain {\n    static lc_name() {\n        return \"RefineDocumentsChain\";\n    }\n    get defaultDocumentPrompt() {\n        return new PromptTemplate({\n            inputVariables: [\"page_content\"],\n            template: \"{page_content}\",\n        });\n    }\n    get inputKeys() {\n        return [\n            ...new Set([\n                this.inputKey,\n                ...this.llmChain.inputKeys,\n                ...this.refineLLMChain.inputKeys,\n            ]),\n        ].filter((key) => key !== this.documentVariableName && key !== this.initialResponseName);\n    }\n    get outputKeys() {\n        return [this.outputKey];\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"llmChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"input_documents\"\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"output_text\"\n        });\n        Object.defineProperty(this, \"documentVariableName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"context\"\n        });\n        Object.defineProperty(this, \"initialResponseName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"existing_answer\"\n        });\n        Object.defineProperty(this, \"refineLLMChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"documentPrompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: this.defaultDocumentPrompt\n        });\n        this.llmChain = fields.llmChain;\n        this.refineLLMChain = fields.refineLLMChain;\n        this.documentVariableName =\n            fields.documentVariableName ?? this.documentVariableName;\n        this.inputKey = fields.inputKey ?? this.inputKey;\n        this.outputKey = fields.outputKey ?? this.outputKey;\n        this.documentPrompt = fields.documentPrompt ?? this.documentPrompt;\n        this.initialResponseName =\n            fields.initialResponseName ?? this.initialResponseName;\n    }\n    /** @ignore */\n    async _constructInitialInputs(doc, rest) {\n        const baseInfo = {\n            page_content: doc.pageContent,\n            ...doc.metadata,\n        };\n        const documentInfo = {};\n        this.documentPrompt.inputVariables.forEach((value) => {\n            documentInfo[value] = baseInfo[value];\n        });\n        const baseInputs = {\n            [this.documentVariableName]: await this.documentPrompt.format({\n                ...documentInfo,\n            }),\n        };\n        const inputs = { ...baseInputs, ...rest };\n        return inputs;\n    }\n    /** @ignore */\n    async _constructRefineInputs(doc, res) {\n        const baseInfo = {\n            page_content: doc.pageContent,\n            ...doc.metadata,\n        };\n        const documentInfo = {};\n        this.documentPrompt.inputVariables.forEach((value) => {\n            documentInfo[value] = baseInfo[value];\n        });\n        const baseInputs = {\n            [this.documentVariableName]: await this.documentPrompt.format({\n                ...documentInfo,\n            }),\n        };\n        const inputs = { [this.initialResponseName]: res, ...baseInputs };\n        return inputs;\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        if (!(this.inputKey in values)) {\n            throw new Error(`Document key ${this.inputKey} not found.`);\n        }\n        const { [this.inputKey]: docs, ...rest } = values;\n        const currentDocs = docs;\n        const initialInputs = await this._constructInitialInputs(currentDocs[0], rest);\n        let res = await this.llmChain.predict({ ...initialInputs }, runManager?.getChild(\"answer\"));\n        const refineSteps = [res];\n        for (let i = 1; i < currentDocs.length; i += 1) {\n            const refineInputs = await this._constructRefineInputs(currentDocs[i], res);\n            const inputs = { ...refineInputs, ...rest };\n            res = await this.refineLLMChain.predict({ ...inputs }, runManager?.getChild(\"refine\"));\n            refineSteps.push(res);\n        }\n        return { [this.outputKey]: res };\n    }\n    _chainType() {\n        return \"refine_documents_chain\";\n    }\n    static async deserialize(data) {\n        const SerializedLLMChain = data.llm_chain;\n        if (!SerializedLLMChain) {\n            throw new Error(\"Missing llm_chain\");\n        }\n        const SerializedRefineDocumentChain = data.refine_llm_chain;\n        if (!SerializedRefineDocumentChain) {\n            throw new Error(\"Missing refine_llm_chain\");\n        }\n        return new RefineDocumentsChain({\n            llmChain: await LLMChain.deserialize(SerializedLLMChain),\n            refineLLMChain: await LLMChain.deserialize(SerializedRefineDocumentChain),\n        });\n    }\n    serialize() {\n        return {\n            _type: this._chainType(),\n            llm_chain: this.llmChain.serialize(),\n            refine_llm_chain: this.refineLLMChain.serialize(),\n        };\n    }\n}\n"],"names":["StuffDocumentsChain","lc_name","inputKeys","this","inputKey","llmChain","filter","key","documentVariableName","outputKeys","constructor","fields","super","Object","defineProperty","enumerable","configurable","writable","value","_prepInputs","values","Error","docs","rest","texts","map","pageContent","text","join","_call","runManager","result","call","getChild","_chainType","deserialize","data","llm_chain","LLMChain","serialize","_type","MapReduceDocumentsChain","combineDocumentChain","ensureMapStep","maxTokens","maxIterations","returnIntermediateSteps","currentDocs","intermediateSteps","i","inputs","d","canSkipMapStep","formatted","prompt","format","length","_getNumTokens","withinTokenLimit","results","apply","Array","from","_","undefined","outputKey","concat","r","metadata","newInputs","combine_document_chain","RefineDocumentsChain","defaultDocumentPrompt","inputVariables","template","Set","refineLLMChain","initialResponseName","documentPrompt","_constructInitialInputs","doc","baseInfo","page_content","documentInfo","forEach","baseInputs","_constructRefineInputs","res","initialInputs","predict","refineSteps","refineInputs","push","SerializedLLMChain","SerializedRefineDocumentChain","refine_llm_chain"],"sourceRoot":""}